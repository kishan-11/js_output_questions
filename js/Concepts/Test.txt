Alright, let's break down hoisting in JavaScript in a super clear way:

âœ… Definition:
Hoisting means that JavaScript moves declarations (NOT initializations) to the top of their scope before running the code.

ğŸ”µ Example with var:

javascript
Copy
Edit
console.log(a);  // undefined
var a = 5;
console.log(a);  // 5
Behind the scenes, JavaScript treats it like:

javascript
Copy
Edit
var a;
console.log(a);  // undefined
a = 5;
console.log(a);  // 5
So the declaration (var a;) is hoisted to the top, but the assignment (a = 5) stays in place.

ğŸ”µ What about let and const?

They are also hoisted, BUT they go into a special "Temporal Dead Zone" (TDZ) â€” meaning you cannot access them before the actual line of code where they are declared.

Example:

javascript
Copy
Edit
console.log(b);  // âŒ ReferenceError: Cannot access 'b' before initialization
let b = 10;
Same for const.

Key point:

var â†’ hoisted and initialized as undefined.

let and const â†’ hoisted but NOT initialized â†’ ReferenceError if you access them early.

ğŸ”µ Functions are hoisted too!

javascript
Copy
Edit
sayHi(); // Works fine

function sayHi() {
  console.log("Hello!");
}
Because function declarations are fully hoisted â€” both name and body!

âš¡ BUT: Function expressions (assigned to variables) behave differently:

javascript
Copy
Edit
sayHello();  // âŒ TypeError: sayHello is not a function

var sayHello = function() {
  console.log("Hello!");
};
Here only var sayHello is hoisted as undefined, not the function itself.

ğŸ¯ Quick Summary:

What gets hoisted?	Behavior
var	Hoisted and initialized to undefined
let / const	Hoisted but not initialized (TDZ)
function declaration	Hoisted fully (including body)
function expressions / arrow functions	Variable hoisted as undefined, but function not hoisted